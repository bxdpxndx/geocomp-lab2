// Generated by CoffeeScript 1.4.0
(function() {
  var Circle, Color, Delaunay, HalfEdge, Point, Triangle, black, blue, gray, green, red, white,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.onload = function() {
    var canvas, ctx, delaunay, fps, keymap, mainloop, mouse, newButton;
    fps = 10;
    canvas = document.getElementById('delaunay');
    ctx = canvas.getContext('2d');
    mouse = new Point(0, 0);
    ctx.translate(0.5, 0.5);
    window.setInterval(mainloop, 1000 / fps);
    keymap = {};
    window.onkeypress = function(e) {
      var action, key;
      key = String.fromCharCode(e.which);
      action = keymap[key];
      if (action !== void 0) {
        return action();
      }
    };
    newButton = function(key, text, action) {
      var b;
      b = document.createElement("input");
      b.type = "submit";
      b.className = "btn";
      b.value = text + ' (' + key + ')';
      b.id = key;
      b.onclick = action;
      keymap[key] = action;
      return document.getElementById('buttons').appendChild(b);
    };
    delaunay = new Delaunay(canvas);
    mainloop = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillText("Mouse:" + mouse.x + ', ' + mouse.y, 750, 470);
      return delaunay.draw(ctx);
    };
    window.setInterval(mainloop, 1000 / fps);
    canvas.onclick = function(e) {
      return delaunay.new_point(new Point(e.offsetX, e.offsetY));
    };
    canvas.onmousemove = function(e) {
      return mouse = new Point(e.offsetX, e.offsetY);
    };
    newButton('r', 'Clear', function() {
      return delaunay = new Delaunay(canvas);
    });
    return newButton('q', 'Toggle Circles', function() {
      return delaunay.show_circles = !delaunay.show_circles;
    });
  };

  Circle = (function() {

    function Circle(c, r, color) {
      this.c = c;
      this.r = r;
      this.color = color != null ? color : blue;
    }

    Circle.prototype.contains = function(point) {
      return this.r * this.r < (this.c.x - point.x) * (this.c.x - point.x) + (this.c.y - point.y) * (this.c.y - point.y);
    };

    Circle.prototype.draw = function(ctx, hl) {
      if (hl == null) {
        hl = false;
      }
      ctx.beginPath();
      ctx.arc(this.c.x, this.c.y, this.r, 0, 2 * Math.PI);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Circle;

  })();

  Color = (function() {

    Color.prototype.r = null;

    Color.prototype.g = null;

    Color.prototype.b = null;

    function Color(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }

    Color.prototype.asHex = function() {
      return '#' + ("0" + this.r.toString(16)).slice(-2) + ("0" + this.g.toString(16)).slice(-2) + ("0" + this.b.toString(16)).slice(-2);
    };

    return Color;

  })();

  black = new Color(0, 0, 0);

  gray = new Color(128, 128, 128);

  white = new Color(255, 255, 255);

  red = new Color(255, 0, 0);

  blue = new Color(0, 0, 255);

  green = new Color(0, 255, 0);

  Delaunay = (function() {

    function Delaunay(canvas) {
      var i, inside, outside, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _ref4;
      this.show_circles = false;
      inside = new Triangle();
      outside = new Triangle();
      this.points = [new Point(canvas.width / 2, -1500), new Point(canvas.width + 1000, canvas.height + 1000), new Point(-1000, canvas.height + 1000)];
      this.faces = [inside, outside];
      this.edges = [];
      for (i = _i = 0, _ref = this.points.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.edges.push(new HalfEdge(this.points[i], inside));
      }
      for (i = _j = 0, _ref1 = this.points.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.edges.push(new HalfEdge(this.points[2 - i], outside));
      }
      this.faces[0].edge = this.edges[0];
      this.faces[1].edge = this.edges[3];
      for (i = _k = 0, _ref2 = this.points.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.edges[i].next = this.edges[(i + 1) % 3];
        this.edges[i + 3].next = this.edges[(i + 1) % 3 + 3];
      }
      _ref3 = [this.edges[4], this.edges[3]], this.edges[3] = _ref3[0], this.edges[4] = _ref3[1];
      for (i = _l = 0, _ref4 = this.points.length; 0 <= _ref4 ? _l < _ref4 : _l > _ref4; i = 0 <= _ref4 ? ++_l : --_l) {
        this.edges[i].opposite = this.edges[i + 3];
        this.edges[i].opposite.opposite = this.edges[i];
      }
    }

    Delaunay.prototype.new_point = function(point) {
      var t, t0, t1, tri, _ref;
      this.points.push(point);
      tri = (function() {
        var _i, _len, _ref, _results;
        _ref = this.triangles;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t.contains(point)) {
            _results.push(t);
          }
        }
        return _results;
      }).call(this);
      tri = tri[0];
      this.retriangulate(tri, point);
      while (this.needs_checking.length) {
        _ref = this.needs_checking.pop(), t0 = _ref[0], t1 = _ref[1];
        if (t0.nbs.some(function(x) {
          return x === null;
        }) || t1.nbs.some(function(x) {
          return x === null;
        })) {
          continue;
        } else {
          this.flip_triangles(t0, t1);
        }
      }
    };

    Delaunay.prototype.retriangulate = function(tri, point) {
      var p0, p1, p2, t0, t1, t2, x, _i, _len, _ref, _ref1;
      _ref = tri.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      t0 = new Triangle(p0, p1, point);
      t1 = new Triangle(point, p1, p2);
      t2 = new Triangle(p0, point, p2);
      t0.nbs = [tri.nbs[0], t1, t2];
      t1.nbs = [t0, tri.nbs[1], t2];
      t2.nbs = [t0, t1, tri.nbs[2]];
      _ref1 = [t0, t1, t2];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        this.triangles.push(x);
      }
      this.triangles.splice(this.triangles.indexOf(tri), 1);
      this.needs_checking.push([t0, t1]);
      this.needs_checking.push([t1, t2]);
      return this.needs_checking.push([t2, t0]);
    };

    Delaunay.prototype.flip_triangles = function(t1, t2) {
      var all_t, c1, c2, free_t1, free_t2, n, n_t1, n_t2, nbs_t1, nbs_t2, t, union, union_t1, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
      union = [];
      free_t1 = [];
      free_t2 = [];
      _ref = t1.vertexs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (__indexOf.call(t2.vertexs, t) < 0) {
          free_t1.push(t);
        }
      }
      _ref1 = t2.vertexs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        if (__indexOf.call(t1.vertexs, t) < 0) {
          free_t2.push(t);
        }
      }
      _ref2 = t1.vertexs;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        t = _ref2[_k];
        if (__indexOf.call(t2.vertexs, t) >= 0) {
          union.push(t);
        }
      }
      c1 = t1.getCircle();
      c2 = t2.getCircle();
      if (c1.contains(free_t2) || c2.contains(free_t1)) {
        n_t1 = new Triangle(free_t1, free_t2, union[0]);
        n_t2 = new Triangle(free_t1, free_t2, union[1]);
        _ref3 = t1.nbs;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          t = _ref3[_l];
          if (t === !t2) {
            nbs_t1 = t;
          }
        }
        _ref4 = t2.nbs;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          t = _ref4[_m];
          if (t === !t1) {
            nbs_t2 = t;
          }
        }
        all_t = [nbs_t1, nbs_t2];
        _results = [];
        for (_n = 0, _len5 = all_t.length; _n < _len5; _n++) {
          t = all_t[_n];
          _ref5 = n_t1.vertexs;
          for (_o = 0, _len6 = _ref5.length; _o < _len6; _o++) {
            v = _ref5[_o];
            if (__indexOf.call(t.vertexs, v) >= 0) {
              union_t1 = v;
            }
          }
          if (union_t1.length > 1) {
            n_t1.nbs.push(t);
            _results.push((function() {
              var _len7, _p, _ref6, _results1;
              _ref6 = this.triangles;
              _results1 = [];
              for (_p = 0, _len7 = _ref6.length; _p < _len7; _p++) {
                n = _ref6[_p];
                if (n === t) {
                  _results1.push(n = t);
                }
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(n_t2.nbs.push(t));
          }
        }
        return _results;
      }
    };

    Delaunay.prototype.draw = function(ctx) {
      var p, t, t0, t1, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        p.draw(ctx);
      }
      _ref1 = this.triangles;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        t.draw(ctx);
        if (this.show_circles) {
          t.getCircle().draw(ctx);
        }
      }
      _ref2 = this.needs_checking;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        _ref3 = _ref2[_k], t0 = _ref3[0], t1 = _ref3[1];
        ctx.beginPath();
        ctx.moveTo(t0.center().x, t0.center().y);
        ctx.lineTo(t1.center().x, t1.center().y);
        ctx.stroke();
        return;
      }
    };

    return Delaunay;

  })();

  Point = (function() {

    function Point(x, y, color) {
      if (color == null) {
        color = black;
      }
      this.x = x;
      this.y = y;
      this.color = color;
    }

    Point.prototype.add = function(other) {
      return new Point(this.x + other.x, this.y + other.y);
    };

    Point.prototype.sub = function(other) {
      return new Point(this.x - other.x, this.y - other.y);
    };

    Point.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Point.prototype.draw = function(ctx) {
      var sz;
      sz = 2;
      ctx.beginPath();
      ctx.moveTo(this.x - sz, this.y - sz);
      ctx.lineTo(this.x + sz, this.y + sz);
      ctx.moveTo(this.x + sz, this.y - sz);
      ctx.lineTo(this.x - sz, this.y + sz);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Point;

  })();

  HalfEdge = (function() {

    function HalfEdge(origin, face, opposite, next) {
      this.origin = origin;
      this.face = face;
      this.opposite = opposite != null ? opposite : null;
      this.next = next != null ? next : null;
      this.id = Math.random();
    }

    HalfEdge.prototype.toString = function() {
      return "edge " + this.id + " from " + this.origin.x + "," + this.origin.y + " to " + this.next.origin.x + "," + this.next.origin.y;
    };

    return HalfEdge;

  })();

  Triangle = (function() {

    function Triangle(edge) {
      this.edge = edge;
    }

    Triangle.prototype.getCircle = function() {
      var center, p0, p0Slope, p1, p1Slope, p2, r, xDelta_p0, xDelta_p1, yDelta_p0, yDelta_p1, _ref;
      center = new Point(0, 0);
      _ref = [this.edge.origin, this.edge.next.origin, this.edge.next.next.origin], p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      yDelta_p0 = p1.y - p0.y;
      xDelta_p0 = p1.x - p0.x;
      yDelta_p1 = p2.y - p1.y;
      xDelta_p1 = p2.x - p1.x;
      p0Slope = yDelta_p0 / xDelta_p0;
      p1Slope = yDelta_p1 / xDelta_p1;
      center.x = (p0Slope * p1Slope * (p0.y - p2.y) + p1Slope * (p0.x + p1.x) - p0Slope * (p1.x + p2.x)) / (2 * (p1Slope - p0Slope));
      center.y = -1 * (center.x - (p0.x + p1.x) / 2) / p0Slope + (p0.y + p1.y) / 2;
      r = center.sub(p0);
      r = r.norm();
      return new Circle(center, r);
    };

    Triangle.prototype.contains = function(point) {
      var dot00, dot01, dot02, dot11, dot12, invDenom, p0, p1, p2, u, v, v0, v1, v2, _ref;
      _ref = [this.edge.origin, this.edge.next.origin, this.edge.next.next.origin], p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      v0 = p2.sub(p0);
      v1 = p1.sub(p0);
      v2 = point.sub(p0);
      dot00 = v0.dot(v0);
      dot01 = v0.dot(v1);
      dot02 = v0.dot(v2);
      dot11 = v1.dot(v1);
      dot12 = v1.dot(v2);
      invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
      u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return (u >= 0) && (v >= 0) && (u + v < 1);
    };

    Triangle.prototype.draw = function(ctx, hl) {
      var p0, p1, p2, _ref;
      if (hl == null) {
        hl = false;
      }
      _ref = this.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p0.x, p0.y);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Triangle;

  })();

}).call(this);
