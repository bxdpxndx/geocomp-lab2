// Generated by CoffeeScript 1.7.1
(function() {
  var Circle, Color, Delaunay, Point, Triangle, black, blue, gray, green, red, white,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Circle = (function() {
    function Circle(c, r, color) {
      if (color == null) {
        color = blue;
      }
      this.c = c;
      this.r = r;
      this.color = color;
    }

    Circle.prototype.contains = function(point) {
      return this.r * this.r < (this.c.x - point.x) * (this.c.x - point.x) + (this.c.y - point.y) * (this.c.y - point.y);
    };

    Circle.prototype.draw = function(ctx) {
      ctx.beginPath();
      ctx.arc(this.c.x, this.c.y, this.r, 0, 2 * Math.PI);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Circle;

  })();

  Color = (function() {
    Color.prototype.r = null;

    Color.prototype.g = null;

    Color.prototype.b = null;

    function Color(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }

    Color.prototype.asHex = function() {
      return '#' + ("0" + this.r.toString(16)).slice(-2) + ("0" + this.g.toString(16)).slice(-2) + ("0" + this.b.toString(16)).slice(-2);
    };

    return Color;

  })();

  black = new Color(0, 0, 0);

  gray = new Color(128, 128, 128);

  white = new Color(255, 255, 255);

  red = new Color(255, 0, 0);

  blue = new Color(0, 0, 255);

  green = new Color(0, 255, 0);

  Delaunay = (function() {
    function Delaunay(canvas) {
      this.supertriangle = new Triangle(new Point(canvas.width / 2, -1500), new Point(-1000, canvas.height + 1000), new Point(canvas.width + 1000, canvas.height + 1000));
      this.triangles = [this.supertriangle];
      this.points = this.supertriangle.vertexs.slice();
      this.needs_checking = [];
      this.show_circles = false;
    }

    Delaunay.prototype.new_point = function(point) {
      var t, t0, t1, tri, _ref;
      this.points.push(point);
      tri = (function() {
        var _i, _len, _ref, _results;
        _ref = this.triangles;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t.contains(point)) {
            _results.push(t);
          }
        }
        return _results;
      }).call(this);
      tri = tri[0];
      this.retriangulate(tri, point);
      while (this.needs_checking.length) {
        _ref = this.needs_checking.pop(), t0 = _ref[0], t1 = _ref[1];
        if (t0.nbs.some(function(x) {
          return x === null;
        }) || t1.nbs.some(function(x) {
          return x === null;
        })) {
          continue;
        } else {
          this.flip_triangles(t0, t1);
        }
      }
    };

    Delaunay.prototype.retriangulate = function(tri, point) {
      var p0, p1, p2, t0, t1, t2, x, _i, _len, _ref, _ref1;
      _ref = tri.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      t0 = new Triangle(p0, p1, point);
      t1 = new Triangle(point, p1, p2);
      t2 = new Triangle(p0, point, p2);
      t0.nbs = [tri.nbs[0], t1, t2];
      t1.nbs = [t0, tri.nbs[1], t2];
      t2.nbs = [t0, t1, tri.nbs[2]];
      _ref1 = [t0, t1, t2];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        this.triangles.push(x);
      }
      this.triangles.splice(this.triangles.indexOf(tri), 1);
      this.needs_checking.push([t0, t1]);
      this.needs_checking.push([t1, t2]);
      return this.needs_checking.push([t2, t0]);
    };

    Delaunay.prototype.flip_triangles = function(t1, t2) {
      var c1, c2, free_p, free_t1, free_t2, n, n_t1, n_t2, nbs_t, p, t, union, union_t1, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results;
      union = [];
      free_t1 = [];
      free_t2 = [];
      _ref = t1.vertexs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (__indexOf.call(t2.vertexs, t) < 0) {
          free_t1.push(t);
        }
      }
      _ref1 = t2.vertexs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        if (__indexOf.call(t1.vertexs, t) < 0) {
          free_t2.push(t);
        }
      }
      _ref2 = t1.vertexs;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        t = _ref2[_k];
        if (__indexOf.call(t2.vertexs, t) >= 0) {
          union.push(t);
        }
      }
      c1 = t1.getCircle();
      c2 = t2.getCircle();
      console.log(c1.contains(free_t2[0]), c2.contains(free_t1[0]));
      if (c1.contains(free_t2[0]) || c2.contains(free_t1[0])) {
        n_t1 = new Triangle(free_t1, free_t2, union[0]);
        n_t2 = new Triangle(free_t1, free_t2, union[1]);
        nbs_t = [];
        _ref3 = t1.nbs;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          t = _ref3[_l];
          free_p = [];
          _ref4 = t.vertexs;
          for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
            p = _ref4[_m];
            if (__indexOf.call(t2.vertexs, p) < 0) {
              free_p.push(p);
            }
          }
          if (free_p.length) {
            nbs_t.push(t);
          }
        }
        _ref5 = t2.nbs;
        for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
          t = _ref5[_n];
          free_p = [];
          _ref6 = t.vertexs;
          for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
            p = _ref6[_o];
            if (__indexOf.call(t1.vertexs, p) < 0) {
              free_p.push(p);
            }
          }
          if (free_p.length) {
            nbs_t.push(t);
          }
        }
        console.log(t1.nbs, t2.nbs, nbs_t);
        _results = [];
        for (_p = 0, _len7 = all_t.length; _p < _len7; _p++) {
          t = all_t[_p];
          _ref7 = n_t1.vertexs;
          for (_q = 0, _len8 = _ref7.length; _q < _len8; _q++) {
            v = _ref7[_q];
            if (__indexOf.call(t.vertexs, v) >= 0) {
              union_t1 = v;
            }
          }
          if (union_t1.length > 1) {
            n_t1.nbs.push(t);
            _results.push((function() {
              var _len9, _r, _ref8, _results1;
              _ref8 = this.triangles;
              _results1 = [];
              for (_r = 0, _len9 = _ref8.length; _r < _len9; _r++) {
                n = _ref8[_r];
                if (n === t) {
                  _results1.push(n = t);
                }
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(n_t2.nbs.push(t));
          }
        }
        return _results;
      }
    };

    Delaunay.prototype.draw = function(ctx) {
      var p, t, t0, t1, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        p.draw(ctx);
      }
      _ref1 = this.triangles;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        t.draw(ctx);
        if (this.show_circles) {
          t.getCircle().draw(ctx);
        }
      }
      _ref2 = this.needs_checking;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        _ref3 = _ref2[_k], t0 = _ref3[0], t1 = _ref3[1];
        ctx.beginPath();
        ctx.moveTo(t0.center().x, t0.center().y);
        ctx.lineTo(t1.center().x, t1.center().y);
        ctx.stroke();
        return;
      }
    };

    return Delaunay;

  })();

  Point = (function() {
    function Point(x, y, color) {
      if (color == null) {
        color = black;
      }
      this.x = x;
      this.y = y;
      this.color = color;
    }

    Point.prototype.add = function(other) {
      return new Point(this.x + other.x, this.y + other.y);
    };

    Point.prototype.sub = function(other) {
      return new Point(this.x - other.x, this.y - other.y);
    };

    Point.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Point.prototype.draw = function(ctx) {
      var sz;
      sz = 2;
      ctx.beginPath();
      ctx.moveTo(this.x - sz, this.y - sz);
      ctx.lineTo(this.x + sz, this.y + sz);
      ctx.moveTo(this.x + sz, this.y - sz);
      ctx.lineTo(this.x - sz, this.y + sz);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Point;

  })();

  Triangle = (function() {
    function Triangle(p0, p1, p2, color) {
      if (color == null) {
        color = green;
      }
      this.vertexs = [p0, p1, p2];
      this.nbs = [null, null, null];
      this.color = color;
    }

    Triangle.prototype.getCircle = function() {
      var center, p0, p0Slope, p1, p1Slope, p2, r, xDelta_p0, xDelta_p1, yDelta_p0, yDelta_p1, _ref;
      center = new Point(0, 0);
      _ref = this.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      yDelta_p0 = p1.y - p0.y;
      xDelta_p0 = p1.x - p0.x;
      yDelta_p1 = p2.y - p1.y;
      xDelta_p1 = p2.x - p1.x;
      p0Slope = yDelta_p0 / xDelta_p0;
      p1Slope = yDelta_p1 / xDelta_p1;
      center.x = (p0Slope * p1Slope * (p0.y - p2.y) + p1Slope * (p0.x + p1.x) - p0Slope * (p1.x + p2.x)) / (2 * (p1Slope - p0Slope));
      center.y = -1 * (center.x - (p0.x + p1.x) / 2) / p0Slope + (p0.y + p1.y) / 2;
      r = center.sub(p0);
      r = r.norm();
      return new Circle(center, r);
    };

    Triangle.prototype.center = function() {
      var v;
      return new Point(sum((function() {
        var _i, _len, _ref, _results;
        _ref = this.vertexs;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(v.x);
        }
        return _results;
      }).call(this)) / 3, sum((function() {
        var _i, _len, _ref, _results;
        _ref = this.vertexs;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          _results.push(v.y);
        }
        return _results;
      }).call(this)) / 3);
    };

    Triangle.prototype.contains = function(point) {
      var dot00, dot01, dot02, dot11, dot12, invDenom, p0, p1, p2, u, v, v0, v1, v2, _ref;
      _ref = this.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      v0 = p2.sub(p0);
      v1 = p1.sub(p0);
      v2 = point.sub(p0);
      dot00 = v0.dot(v0);
      dot01 = v0.dot(v1);
      dot02 = v0.dot(v2);
      dot11 = v1.dot(v1);
      dot12 = v1.dot(v2);
      invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
      u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return (u >= 0) && (v >= 0) && (u + v < 1);
    };

    Triangle.prototype.draw = function(ctx, hl) {
      var p0, p1, p2, _ref;
      if (hl == null) {
        hl = false;
      }
      _ref = this.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p0.x, p0.y);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Triangle;

  })();

  window.onload = function() {
    var canvas, ctx, delaunay, fps, keymap, mainloop, mouse, newButton;
    fps = 10;
    canvas = document.getElementById('delaunay');
    ctx = canvas.getContext('2d');
    mouse = new Point(0, 0);
    ctx.translate(0.5, 0.5);
    window.setInterval(mainloop, 1000 / fps);
    keymap = {};
    window.onkeypress = function(e) {
      var action, key;
      key = String.fromCharCode(e.which);
      action = keymap[key];
      if (action !== void 0) {
        return action();
      }
    };
    newButton = function(key, text, action) {
      var b;
      b = document.createElement("input");
      b.type = "submit";
      b.className = "btn";
      b.value = text + ' (' + key + ')';
      b.id = key;
      b.onclick = action;
      keymap[key] = action;
      return document.getElementById('buttons').appendChild(b);
    };
    delaunay = new Delaunay(canvas);
    mainloop = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillText("Mouse:" + mouse.x + ', ' + mouse.y, 750, 470);
      return delaunay.draw(ctx);
    };
    window.setInterval(mainloop, 1000 / fps);
    canvas.onclick = function(e) {
      return delaunay.new_point(new Point(e.offsetX, e.offsetY));
    };
    canvas.onmousemove = function(e) {
      return mouse = new Point(e.offsetX, e.offsetY);
    };
    newButton('r', 'Clear', function() {
      return delaunay = new Delaunay(canvas);
    });
    return newButton('q', 'Toggle Circles', function() {
      return delaunay.show_circles = !delaunay.show_circles;
    });
  };

}).call(this);
