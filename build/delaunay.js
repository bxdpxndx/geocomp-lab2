// Generated by CoffeeScript 1.4.0
(function() {
  var Circle, Color, Delaunay, Point, QuadEdge, Triangle, black, blue, gray, green, red, white;

  Circle = (function() {

    function Circle(c, r, color) {
      if (color == null) {
        color = blue;
      }
      this.c = c;
      this.r = r;
      this.color = color;
    }

    Circle.prototype.contains = function(point) {
      return this.r * this.r > (this.c.x - point.x) * (this.c.x - point.x) + (this.c.y - point.y) * (this.c.y - point.y);
    };

    Circle.prototype.draw = function(ctx) {
      ctx.beginPath();
      ctx.arc(this.c.x, this.c.y, this.r, 0, 2 * Math.PI);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Circle;

  })();

  Color = (function() {

    Color.prototype.r = null;

    Color.prototype.g = null;

    Color.prototype.b = null;

    function Color(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }

    Color.prototype.asHex = function() {
      return '#' + ("0" + this.r.toString(16)).slice(-2) + ("0" + this.g.toString(16)).slice(-2) + ("0" + this.b.toString(16)).slice(-2);
    };

    return Color;

  })();

  black = new Color(0, 0, 0);

  gray = new Color(128, 128, 128);

  white = new Color(255, 255, 255);

  red = new Color(255, 0, 0);

  blue = new Color(0, 0, 255);

  green = new Color(0, 255, 0);

  Delaunay = (function() {

    function Delaunay() {}

    Delaunay.prototype.reset = function() {
      return {
        constructor: console.log('Reset!')
      };
    };

    return Delaunay;

  })();

  Point = (function() {

    function Point(x, y, color) {
      if (color == null) {
        color = black;
      }
      this.x = x;
      this.y = y;
      this.color = color;
    }

    Point.prototype.add = function(other) {
      return new Point(this.x + other.x, this.y + other.y);
    };

    Point.prototype.sub = function(other) {
      return new Point(this.x - other.x, this.y - other.y);
    };

    Point.prototype.dot = function(other) {
      return new Point(this.x * other.x, this.y * other.y);
    };

    Point.prototype.mult = function(other) {
      return new Point(this.x * other, this.y * other);
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Point.prototype.draw = function(ctx) {
      var sz;
      sz = 2;
      ctx.beginPath();
      ctx.moveTo(this.x - sz, this.y - sz);
      ctx.lineTo(this.x + sz, this.y + sz);
      ctx.moveTo(this.x + sz, this.y - sz);
      ctx.lineTo(this.x - sz, this.y + sz);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Point;

  })();

  Triangle = (function() {

    function Triangle(p0, p1, p2, color) {
      if (color == null) {
        color = green;
      }
      this.p0 = p0;
      this.p1 = p1;
      this.p2 = p2;
      this.color = color;
    }

    Triangle.prototype.getCircle = function() {
      var center, p0Slope, p1Slope, r, xDelta_p0, xDelta_p1, yDelta_p0, yDelta_p1;
      center = new Point(0, 0);
      yDelta_p0 = this.p1.y - this.p0.y;
      xDelta_p0 = this.p1.x - this.p0.x;
      yDelta_p1 = this.p2.y - this.p1.y;
      xDelta_p1 = this.p2.x - this.p1.x;
      p0Slope = yDelta_p0 / xDelta_p0;
      p1Slope = yDelta_p1 / xDelta_p1;
      center.x = (p0Slope * p1Slope * (this.p0.y - this.p2.y) + p1Slope * (this.p0.x + this.p1.x) - p0Slope * (this.p1.x + this.p2.x)) / (2 * (p1Slope - p0Slope));
      center.y = -1 * (center.x - (this.p0.x + this.p1.x) / 2) / p0Slope + (this.p0.y + this.p1.y) / 2;
      r = center.sub(this.p0);
      r = r.norm();
      return new Circle(center, r);
    };

    Triangle.prototype.contains = function(point) {
      return this.getCircle().contains(point);
    };

    Triangle.prototype.draw = function(ctx) {
      ctx.beginPath();
      ctx.moveTo(this.p0.x, this.p0.y);
      ctx.lineTo(this.p1.x, this.p1.y);
      ctx.lineTo(this.p2.x, this.p2.y);
      ctx.lineTo(this.p0.x, this.p0.y);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Triangle;

  })();

  window.onload = function() {
    var canvas, circles, ctx, fps, keymap, mainloop, mouse, newButton, points, show_circles, supertriangle, triangles;
    fps = 30;
    canvas = document.getElementById('delaunay');
    ctx = canvas.getContext('2d');
    mouse = new Point(0, 0);
    ctx.translate(0.5, 0.5);
    window.setInterval(mainloop, 1000 / fps);
    keymap = {};
    window.onkeypress = function(e) {
      var action, key;
      key = String.fromCharCode(e.which);
      action = keymap[key];
      if (action !== void 0) {
        return action();
      }
    };
    newButton = function(key, text, action) {
      var b;
      b = document.createElement("input");
      b.type = "submit";
      b.className = "btn";
      b.value = text;
      b.id = key;
      b.onclick = action;
      keymap[key] = action;
      return document.getElementById('buttons').appendChild(b);
    };
    points = [];
    supertriangle = new Triangle(new Point(420, -1000), new Point(-1000, 2000), new Point(1840, 2001));
    triangles = [supertriangle];
    circles = [];
    show_circles = false;
    mainloop = function() {
      var i, p, t, _i, _j, _len, _ref, _results;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        p = points[_i];
        p.draw(ctx);
      }
      _results = [];
      for (i = _j = 0, _ref = points.length - 2; _j <= _ref; i = _j += 3) {
        if (points.length > i + 2) {
          t = new Triangle(points[i], points[i + 1], points[i + 2]);
        } else {
          t = new Triangle(points[i], points[i + 1], mouse);
        }
        t.draw(ctx);
        if (show_circles) {
          _results.push(t.getCircle().draw(ctx));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    window.setInterval(mainloop, 1000 / fps);
    canvas.onclick = function(e) {
      var t, tri;
      points.push(mouse);
      tri = [
        (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = triangles.length; _i < _len; _i++) {
            t = triangles[_i];
            if (t.contains(mouse)) {
              _results.push(t);
            }
          }
          return _results;
        })()
      ];
      tri = tri[0];
      triangles.push(new Triangle(tri.p0, tri.p1, mouse));
      triangles.push(new Triangle(tri.p1, tri.p2, mouse));
      return triangles.push(new Triangle(tri.p2, tri.p0, mouse));
    };
    canvas.onmousemove = function(e) {
      return mouse = new Point(e.offsetX, e.offsetY);
    };
    newButton('r', 'Clear', function() {
      return points = [];
    });
    return newButton('q', 'Toggle Circles', function() {
      return show_circles = !show_circles;
    });
  };

  QuadEdge = (function() {

    function QuadEdge() {}

    return QuadEdge;

  })();

}).call(this);
