// Generated by CoffeeScript 1.4.0
(function() {
  var Circle, Color, Delaunay, Point, Triangle, black, blue, gray, green, red, white;

  window.onload = function() {
    var canvas, ctx, delaunay, fps, keymap, mainloop, mouse, newButton;
    fps = 10;
    canvas = document.getElementById('delaunay');
    ctx = canvas.getContext('2d');
    mouse = new Point(0, 0);
    ctx.translate(0.5, 0.5);
    window.setInterval(mainloop, 1000 / fps);
    keymap = {};
    window.onkeypress = function(e) {
      var action, key;
      key = String.fromCharCode(e.which);
      action = keymap[key];
      if (action !== void 0) {
        return action();
      }
    };
    newButton = function(key, text, action) {
      var b;
      b = document.createElement("input");
      b.type = "submit";
      b.className = "btn";
      b.value = text + ' (' + key + ')';
      b.id = key;
      b.onclick = action;
      keymap[key] = action;
      return document.getElementById('buttons').appendChild(b);
    };
    delaunay = new Delaunay(canvas);
    mainloop = function() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillText("Mouse:" + mouse.x + ', ' + mouse.y, 750, 470);
      return delaunay.draw(ctx);
    };
    window.setInterval(mainloop, 1000 / fps);
    canvas.onclick = function(e) {
      return delaunay.new_point(new Point(e.offsetX, e.offsetY));
    };
    canvas.onmousemove = function(e) {
      return mouse = new Point(e.offsetX, e.offsetY);
    };
    newButton('r', 'Clear', function() {
      return delaunay = new Delaunay(canvas);
    });
    return newButton('q', 'Toggle Circles', function() {
      return delaunay.show_circles = !delaunay.show_circles;
    });
  };

  Circle = (function() {

    function Circle(c, r, color) {
      if (color == null) {
        color = blue;
      }
      this.c = c;
      this.r = r;
      this.color = color;
    }

    Circle.prototype.contains = function(point) {
      return this.r * this.r > (this.c.x - point.x) * (this.c.x - point.x) + (this.c.y - point.y) * (this.c.y - point.y);
    };

    Circle.prototype.draw = function(ctx) {
      ctx.beginPath();
      ctx.arc(this.c.x, this.c.y, this.r, 0, 2 * Math.PI);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Circle;

  })();

  Color = (function() {

    Color.prototype.r = null;

    Color.prototype.g = null;

    Color.prototype.b = null;

    function Color(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }

    Color.prototype.asHex = function() {
      return '#' + ("0" + this.r.toString(16)).slice(-2) + ("0" + this.g.toString(16)).slice(-2) + ("0" + this.b.toString(16)).slice(-2);
    };

    return Color;

  })();

  black = new Color(0, 0, 0);

  gray = new Color(128, 128, 128);

  white = new Color(255, 255, 255);

  red = new Color(255, 0, 0);

  blue = new Color(0, 0, 255);

  green = new Color(0, 255, 0);

  Delaunay = (function() {

    function Delaunay(canvas) {
      this.points = [];
      this.supertriangle = new Triangle(new Point(canvas.width / 2, -1500), new Point(-1000, canvas.height + 1000), new Point(canvas.width + 1000, canvas.height + 1000));
      this.triangles = [this.supertriangle];
      this.needs_checking = [];
      this.show_circles = false;
    }

    Delaunay.prototype.new_point = function(point) {
      var t, t0, t1, tri, _ref;
      this.points.push(point);
      tri = (function() {
        var _i, _len, _ref, _results;
        _ref = this.triangles;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t.contains(point)) {
            _results.push(t);
          }
        }
        return _results;
      }).call(this);
      tri = tri[0];
      this.retriangulate(tri, point);
      while (needs_checking) {
        _ref = needs_checking.pop(), t0 = _ref[0], t1 = _ref[1];
        flip_triangles(t0, t1);
      }
      return console.log(this.triangles.length);
    };

    Delaunay.prototype.retriangulate = function(tri, point) {
      var p0, p1, p2, t0, t1, t2, x, _i, _len, _ref, _ref1;
      _ref = tri.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      t0 = new Triangle(tri.p0, tri.p1, point);
      t1 = new Triangle(point, tri.p1, tri.p2);
      t2 = new Triangle(tri.p0, point, tri.p2);
      t0.n0 = tri.nbs[0];
      t0.n1 = t1;
      t0.n2 = t2;
      t1.n0 = t0;
      t1.n1 = tri.nbs[1];
      t1.n2 = t2;
      t2.n0 = t0;
      t2.n1 = t1;
      t2.n2 = tri.nbs[2];
      tri.nbs[0].splice(tri.nbs[0].nbs.indexOf(tri), 1);
      tri.nbs[0].push(t0);
      tri.nbs[1].splice(tri.nbs[1].nbs.indexOf(tri), 1);
      tri.nbs[1].push(t1);
      tri.nbs[2].splice(tri.nbs[2].nbs.indexOf(tri), 1);
      tri.nbs[2].push(t2);
      _ref1 = [t0, t1, t2];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        this.triangles.push(x);
      }
      return this.triangles.splice(this.triangles.indexOf(tri), 1);
    };

    Delaunay.prototype.flip_triangles = function(t1, t2) {};

    Delaunay.prototype.draw = function(ctx) {
      var p, t, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        p.draw(ctx);
      }
      _ref1 = this.triangles;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        t = _ref1[_j];
        t.draw(ctx);
      }
      _ref2 = this.triangles;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        t = _ref2[_k];
        if (this.show_circles) {
          t.getCircle().draw(ctx);
        }
      }
    };

    return Delaunay;

  })();

  Point = (function() {

    function Point(x, y, color) {
      if (color == null) {
        color = black;
      }
      this.x = x;
      this.y = y;
      this.color = color;
    }

    Point.prototype.add = function(other) {
      return new Point(this.x + other.x, this.y + other.y);
    };

    Point.prototype.sub = function(other) {
      return new Point(this.x - other.x, this.y - other.y);
    };

    Point.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Point.prototype.draw = function(ctx) {
      var sz;
      sz = 2;
      ctx.beginPath();
      ctx.moveTo(this.x - sz, this.y - sz);
      ctx.lineTo(this.x + sz, this.y + sz);
      ctx.moveTo(this.x + sz, this.y - sz);
      ctx.lineTo(this.x - sz, this.y + sz);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Point;

  })();

  Triangle = (function() {

    function Triangle(p0, p1, p2, color) {
      if (color == null) {
        color = green;
      }
      this.vertexs = [p0, p1, p2];
      this.nbs = [null, null, null];
      this.color = color;
    }

    Triangle.prototype.getCircle = function() {
      var center, p0Slope, p1, p1Slope, p2, p3, r, xDelta_p0, xDelta_p1, yDelta_p0, yDelta_p1, _ref;
      center = new Point(0, 0);
      _ref = this.vertexs, p1 = _ref[0], p2 = _ref[1], p3 = _ref[2];
      yDelta_p0 = p1.y - p0.y;
      xDelta_p0 = p1.x - p0.x;
      yDelta_p1 = p2.y - p1.y;
      xDelta_p1 = p2.x - p1.x;
      p0Slope = yDelta_p0 / xDelta_p0;
      p1Slope = yDelta_p1 / xDelta_p1;
      center.x = (p0Slope * p1Slope * (p0.y - p2.y) + p1Slope * (p0.x + p1.x) - p0Slope * (p1.x + p2.x)) / (2 * (p1Slope - p0Slope));
      center.y = -1 * (center.x - (p0.x + p1.x) / 2) / p0Slope + (p0.y + p1.y) / 2;
      r = center.sub(this.p0);
      r = r.norm();
      return new Circle(center, r);
    };

    Triangle.prototype.contains = function(point) {
      var dot00, dot01, dot02, dot11, dot12, invDenom, p0, p1, p2, u, v, v0, v1, v2, _ref;
      _ref = this.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      v0 = p2.sub(p0);
      v1 = p1.sub(p0);
      v2 = point.sub(p0);
      dot00 = v0.dot(v0);
      dot01 = v0.dot(v1);
      dot02 = v0.dot(v2);
      dot11 = v1.dot(v1);
      dot12 = v1.dot(v2);
      invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
      u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return (u >= 0) && (v >= 0) && (u + v < 1);
    };

    Triangle.prototype.draw = function(ctx) {
      var p0, p1, p2, _ref;
      _ref = this.vertexs, p0 = _ref[0], p1 = _ref[1], p2 = _ref[2];
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p0.x, p0.y);
      ctx.strokeStyle = this.color.asHex();
      return ctx.stroke();
    };

    return Triangle;

  })();

}).call(this);
